.. _CID-1289:

==================================
Do not bind a user that's disabled
==================================

~~~~~~~~~~~
Description
~~~~~~~~~~~
Currently, when a user attempts to authenticate w/ password Identity performs
the following:

1. Looks up the user by supplied username
2. If no user found, return 401 w/ message "Unable to authenticate user with
   credentials provided."
3. Attempt to bind w/ supplied pwd.
4. If pwd invalid, returns 401 w/ message "Unable to authenticate user with
   credentials provided."
5. If correct pwd, and either the user is disabled or domain is disabled,
   returns a 403 w/ message "User '" + user.getUsername() +"' is disabled.

This logic reduces our ability to respond to bad actors. For example, in the
case of a user attempting to perform excessive auth attempts (e.g. bad actor or
misconfigured program) a standard response would be to simply disable the user.
However, given the above logic, this would still result in a search and a bind
before even checking whether the user is disabled. Binds have additional cost
beyond simply checking passwords. The directory must replicate successful (and
unsuccessful) binds across all nodes to support locking for failed password
attempts. Ultimately, this means we use resources when the request will
ultimately be rejected anyway.

As a real life use case, the top Identity API consumer in identity for a while
has been a user attempting to authenticate against a single user account. This
is either a brute force attack against a user's password or a runaway service
with an old pwd. We disabled the user long ago after noticing the degree of
calls. However, as described above, we still do a directory search and bind for
each call.

We perform similar logic when authenticating via API key - with the exception
that no bind is required; instead the identity application performs the
verification against the stored API key. We must maintain consistent responses
across our auth methods (API and password) for disabled users.

The goal of this story is to further limit the resource consumption of
authenticating against disabled users. Similarly, there are opportunities for
caching disabled user information and eliminating the initial search for the
user completely.

While there is also an additional case where the entire domain is disabled,
which also results in the authentication failing, addressing that scenario would
require an additional refactor to prevent loading the domain multiple times (and
increasing the cost of the far more common "successful" auth case). This can be
addressed in a separate story if desired in order to limit the scope of this
story.

Affected API Services
---------------------
`(POST /v2.0/tokens) <https://pages.github.rackspace.com/ServiceAPIContracts/global-auth-keystone-extensions/api-reference/token-operations.html#authenticate-as-user-with-password-or-api-key>`_
GET /v1.0 (v1.0 Auth)
POST /v1.1/auth
POST /v1.1/auth-admin
All /v1.1 services that accept Basic Auth

All API/Password authentications check whether the user is disabled _after_
performing the authentication. v1.0 auths by API; v1.1 and v2.0 provide both
methods of authentication. While v2.0 also provides an `Auth with Token`
authentication, this authentication does not appear to check the user status.

We must balance resource utilization, information leakage, contract stability,
and usability when a disabled user attempts to login. The current implementation
favors usability (returning 403 for disabled users) and security (authenticating
credential prior to checking disabled status), but does not sufficiently reduce
resource utilization. The following options juggle these a few different ways.

After considerable discussion of various ways to balance the priorities,
we have decided the best way to implement this is to have API nodes cache the
lockout period that CA enforces. While this will not eliminate all binds on
disabled users, it will significantly reduce the number of binds for the targetted
use case of a brute force password attack against a disabled user.

The relevant CA configuration settings are:

.. csv-table:: CA Password Locking Settings
   :header: "Name", "Description", "Staging/Prod Value"

   setpassword-policy,"Whether to enforce password lockout (and policies in
   general).", true
   setpassword-retries,"Number of invalid concurrent invalid auth attempts after
   which account will be suspended.", 50
   setpassword-max-suspension,"Number of seconds an account will be suspended",600

When CA locks out a user it sets the value of the ``dxPwdFailedTime`` attribute
on a user to the date the last bind attempt was made that caused the lockout.
Identity API nodes have a static configuration property
``ldap.password.failure.lockout.min`` that is supposed to mirror the value of
the analogous CA setting, but translated to minutes. This configuration property
is used to determine whether a bind failure against CA occurred because the
account is locked out. Identity determines this by comparing the current time to
``dxPwdFailedTime`` + ``ldap.password.failure.lockout.min``. If the current time
is earlier than this value, then Identity assumes the authentication was denied
because the account is considered "locked out".

The change for this story is to cache the lockout such that subsequent user
retrievals and binds for disabled users that are locked out will not be sent to
CA. The process will be similar to:

1. Check lockout cache for user

   1) If found, determine if lockout time is still in effect

      1) If so, return 401 w/ message "Unable to authenticate user with
         credentials provided
      2) else, remove entry from cache
2. Call CA to bind (check password)
3. If fails and user is disabled, determine if failed due to lockout

   1) If so:

      1) Create cache entry storing when the lockout started
      2) Create audit log for lockout 
      3) Return 401 w/ message "Unable to authenticate user with credentials 
         provided"
6. Normal processing

~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Business Acceptance Criteria
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Implement cache as specified
2. Switch the identity static config property ``ldap.password.failure.lockout.min``
   to be a reloadable configuration property ``ldap.password.auth.lockout.duration``
   that stores the value in seconds (as opposed to minutes)

   1) Default for flag is ``1`` when property is not provided in configuration file
   2) Default for docker configuration is ``1`` 
4. Implement a reloadable feature flag 
   "feature.enable.ldap.password.auth.lockout.cache" to control whether the 
   lockout cache is used. When false, the directory will be hit for each auth
   request as is currently done.

   1) Default for flag is true when property is not provided in configuration file
   2) Default for docker configuration is true 
3) Update default CA docker configuration to represent similar enforcement in
   staging:
   
   1) setpassword-policy=true
   2) setpassword-retries=6
   3) setpassword-max-suspension=1
   4) setpassword-history=0

~~~~~~~~~~~~~~~~~~~~~~~~
Test Acceptance Criteria
~~~~~~~~~~~~~~~~~~~~~~~~
<TBD>
