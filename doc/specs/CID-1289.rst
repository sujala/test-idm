.. _CID-1289:

==================================
Do not bind a user that's disabled
==================================

~~~~~~~~~~~
Description
~~~~~~~~~~~
Currently, when a user attempts to authenticate w/ password Identity performs
the following:

1. Looks up the user by supplied username
2. If no user found, return 401 w/ message "Unable to authenticate user with
   credentials provided."
3. Attempt to bind w/ supplied pwd.
4. If pwd invalid, returns 401 w/ message "Unable to authenticate user with
   credentials provided."
5. If correct pwd, and either the user is disabled or domain is disabled,
   returns a 403 w/ message "User '" + user.getUsername() +"' is disabled.

This logic reduces our ability to respond to bad actors. For example, in the
case of a user attempting to perform excessive auth attempts (e.g. bad actor or
misconfigured program) a standard response would be to simply disable the user.
However, given the above logic, this would still result in a search and a bind
before even checking whether the user is disabled. Binds have additional cost
beyond simply checking passwords. The directory must replicate successful (and
unsuccessful) binds across all nodes to support locking for failed password
attempts. Ultimately, this means we use resources when the request will
ultimately be rejected anyway.

As a real life use case, the top Identity API consumer in identity for a while
has been a user attempting to authenticate against a single user account. This
is either a brute force attack against a user's password or a runaway service
with an old pwd. We disabled the user long ago after noticing the degree of
calls. However, as described above, we still do a directory search and bind for
each call.

We perform similar logic when authenticating via API key - with the exception
that no bind is required; instead the identity application performs the
verification against the stored API key. We must maintain consistent responses
across our auth methods (API and password) for disabled users.

The goal of this story is to further limit the resource consumption of
authenticating against disabled users. Similarly, there are opportunities for
caching disabled user information and eliminating the initial search for the
user completely.

While there is also an additional case where the entire domain is disabled,
which also results in the authentication failing, addressing that scenario would
require an additional refactor to prevent loading the domain multiple times (and
increasing the cost of the far more common "successful" auth case). This can be
addressed in a separate story if desired in order to limit the scope of this
story.

Affected API Services
---------------------
`(POST /v2.0/tokens) <https://pages.github.rackspace.com/ServiceAPIContracts/global-auth-keystone-extensions/api-reference/token-operations.html#authenticate-as-user-with-password-or-api-key>`_
GET /v1.0 (v1.0 Auth)
POST /v1.1/auth
POST /v1.1/auth-admin
All /v1.1 services that accept Basic Auth

All API/Password authentications check whether the user is disabled _after_
performing the authentication. v1.0 auths by API; v1.1 and v2.0 provide both
methods of authentication. While v2.0 also provides an `Auth with Token`
authentication, this authentication does not appear to check the user status.

We must balance resource utilization, information leakage, contract stability,
and usability when a disabled user attempts to login. The current implementation
favors usability (returning 403 for disabled users) and security (authenticating
credential prior to checking disabled status), but does not sufficiently reduce
resource utilization. The following options juggle these a few different ways.

After considerable discussion of various ways to balance the priorities,
we have decided the best way to implement this is to have API nodes cache the
lockout period that CA enforces. While this will not eliminate all binds on
disabled users, it will significantly reduce the number of binds for the targetted
use case of a brute force password attack against a disabled user.

Due to simplicity of the solution, it will be used for both enabled and
disabled users. By including enabled users, the system will automatically reduce
the impact of locked out users - a common situation for runaway service accounts.

--------
CA Logic
--------
Identity uses CA functionality to implement a "lockout" strategy for password
authentication. The relevant CA configuration settings are:

.. csv-table:: CA Password Locking Settings
   :header: "Name", "Description", "Staging/Prod Value"

   password-policy,"Whether to enforce password lockout (and policies in
   general).", true
   password-retries,"Number of invalid concurrent invalid auth attempts after
   which account will be suspended.", 50
   password-max-suspension,"Number of seconds an account will be suspended",600

The following assume password policy is enabled in CA Directory.

The ``dxPwdFailedTime`` and ``dxPwdFailedAttempts`` user attributes
are updated as appropriate for each successive authentication attempt. For a failed
authentication, CA will update the ``dxPwdFailedTime`` user attribute with the 
authentication timestamp in Zulu time and increment the ``dxPwdFailedAttempts``
user attribute. For a successful authentication, these attributes
are removed, if they exist on the user. This process continues until
``password-retries`` successive failed authentication attempts
have occurred. At that point,  ``dxPwdFailedAttempts`` == ``password-retries``
and ``dxPwdFailedTime`` == "time of the last failed authentication." 

At this point the account is considered "locked out", and will remain locked out
until ``password-max-suspension`` seconds have elapsed since that last authentication
attempt. During this period all authentication attempts, regardless of whether
or not the provided password is correct, will fail and neither
of these attributes will be modified. Once
the lockout period has expired the attributes will remain at the last
set values until the user authenticates again. At this time, if successful, CA
removes the attributes; if failure, ``dxPwdFailedAttempts`` is set to 1 and
``dxPwdFailedTime`` is set to the authentication time.

-----------------------
Identity Existing Logic
-----------------------

This is the current
implementation to understand where things stand today. This logic is incorrect
based on how CA works; the required updates to correct this will be described
under Modifications.

Identity API nodes currently have a static configuration property
``ldap.password.failure.lockout.min`` that must mirror the value of
the analogous CA setting, but translated to minutes. This configuration property
is used to determine whether a bind failure against CA occurred because the
account is locked out. Identity determines this by comparing the current time to
``dxPwdFailedTime`` + ``ldap.password.failure.lockout.min``. If the current time
is earlier than this value, then Identity assumes the authentication was denied
because the account is considered "locked out" and will record as such in 
the Identity audit log. 

This will incorrectly record failed auth attempts as
being due to "locked out" for every failed auth attempt after the first for
subsequent ``ldap.password.failure.lockout.min`` minutes.

-------------
Modifications
-------------
The changes for this story include correctly determining whether a user authentication
to CA failed due to lockout and to susequently cache these lockout periods.

Determining User Lockout
^^^^^^^^^^^^^^^^^^^^^^^^
Identity must use the ``dxPwdFailedAttempts`` and ``dxPwdFailedTime`` to
determine whether a user is activelly "locked out." The configuration used by CA for
``password-retries`` and ``password-max-suspension`` must be replicated in
reloadable Identity configuration properties.

The pseudo code would then be:

.. code-block:: java

 boolean isUserLockedOut(User user) {
   boolean lockedOut = false;
   if (user.dxPwdFailedAttempts >= password-retries) {
     DateTime lastFailedDate = user.dxPwdFailedTime
     DateTime lockoutExpiration = lastFailedDate.plusSeconds(password-max-suspension);
     if (lockoutExpiration.isAfterNow()) {
       lockedOut = true;
     }
   }
   return lockedOut;
 }

The audit log must then accurately report, based on the above, whether the
failure was due to lockout.

User Lockout Cache
^^^^^^^^^^^^^^^^^^

The change for this story is to cache the lockout such that subsequent user
retrievals and binds for locked out users will not be sent to
CA. The process will be:

1. Check lockout cache for user

   1) If found, determine if lock out time is still in effect

      1) If so

         1) Create audit log for auth attempt
         2) Return 401 w/ message "Unable to authenticate user with
            credentials provided

      2) else, remove entry from cache
2. Retrieve user from CA based on username and determine if in
   lockout period

   1) If so

      1) Create cache entry for locked out user
      2) Create audit log for lockout 
      3) Return 401 w/ message "Unable to authenticate user with credentials 
         provided"
3. Call CA to bind (check password)
4. If fails, determine if failed due to lockout

   1) If so

      1) Create cache entry for locked out user
      2) Create audit log for auth attempt 
      3) Return 401 w/ message "Unable to authenticate user with credentials 
         provided"
5. Normal processing

The cache must have a maximum size and automatically expire entries after a 
configured amount of time (a TTL). For efficiency, the TTL should always be
set to greater than the lockout period.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Business Acceptance Criteria
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Implement a reloadable configuration property ``ldap.auth.password.lockout.retries``
   to be analogous to the CA setting ``password-retries``

   1) Default for property is ``6`` when property is not provided in configuration file
   2) Default for docker configuration is ``6`` 
2. Switch the identity static config property ``ldap.password.failure.lockout.min``
   to the reloadable configuration property ``ldap.auth.password.lockout.duration``
   that stores the value in seconds (as opposed to minutes)

   1) Default for property is ``1`` when property is not provided in configuration file
   2) Default for docker configuration is ``1`` 

3. Implement cache as specified
   
   1. Implement a reloadable feature flag 
      ``feature.enable.ldap.auth.password.lockout.cache`` to control whether the 
      lockout cache is used. When false, the directory will be hit for each auth
      request as is currently done.

      1) Default for flag is true when property is not provided in configuration file
      2) Default for docker configuration is true 
   2) Implement a reloadable configuration property ``ldap.auth.password.lockout.cache.ttl``
      to specify how long a cache entry will exist until it is automatically removed

      1) Default for property is ``2`` when property is not provided in configuration file
      2) Default for docker configuration is ``2``
   3) Implement a reloadable configuration property ``ldap.auth.password.lockout.cache.size``
      to specify the size of the cache

      1) Default for property is ``5`` when property is not provided in configuration file
      2) Default for docker configuration is ``5``

4. Fix logging to audit log to accurately reflect when auth fails due to lockout
5. Update default CA docker configuration to include password locking behavior
   
   1) password-policy=true
   2) password-retries=6
   3) password-max-suspension=1
   4) password-history=0

~~~~~~~~~~~~~~~~~~~~~~~~
Test Acceptance Criteria
~~~~~~~~~~~~~~~~~~~~~~~~
<TBD>
