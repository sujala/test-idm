import java.util.Arrays;

import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.Filter;
import com.unboundid.ldap.sdk.ReadOnlyEntry;
import com.unboundid.ldap.sdk.persist.DefaultObjectEncoder;
import com.unboundid.ldap.sdk.persist.FieldInfo;
import com.unboundid.ldap.sdk.persist.FilterUsage;
import com.unboundid.ldap.sdk.persist.LDAPEntryField;
import com.unboundid.ldap.sdk.persist.LDAPField;
import com.unboundid.ldap.sdk.persist.LDAPObject;
import com.unboundid.ldap.sdk.persist.LDAPObjectHandler;
import com.unboundid.ldap.sdk.persist.LDAPPersister;
import com.unboundid.ldap.sdk.persist.LDAPPersistException;
import com.unboundid.ldap.sdk.persist.PersistFilterType;



/**
 * This class provides an implementation of an object that can be used to
 * represent baseUrl objects in the directory.
 * It was generated by the generate-source-from-schema tool provided with the
 * UnboundID LDAP SDK for Java.  It may be customized as desired to better suit
 * your needs.
 */
@LDAPObject(structuralClass="baseUrl",
            superiorClass="top",
            postDecodeMethod="doPostDecode",
            postEncodeMethod="doPostEncode")
public class BaseUrl
{
  /*
   * NOTE:  This class includes a number of annotation elements which are not
   * required but have been provided to make it easier to edit the resulting
   * source code.  If you want to exclude these unnecessary annotation
   * elements, use the '--terse' command-line argument.
   */



  // The field to use to hold a read-only copy of the associated entry.
  @LDAPEntryField()
  private ReadOnlyEntry ldapEntry;

  // The field used for RDN attribute rsId.
  @LDAPField(attribute="rsId",
             objectClass="baseUrl",
             inRDN=true,
             filterUsage=FilterUsage.ALWAYS_ALLOWED,
             requiredForEncode=true)
  private String[] rsId;

  // The field used for required attribute publicUrl.
  @LDAPField(attribute="publicUrl",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED,
             requiredForEncode=true)
  private String[] publicUrl;

  // The field used for optional attribute baseUrlType.
  @LDAPField(attribute="baseUrlType",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] baseUrlType;

  // The field used for optional attribute cn.
  @LDAPField(attribute="cn",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] cn;

  // The field used for optional attribute def.
  @LDAPField(attribute="def",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private Boolean[] def;

  // The field used for optional attribute enabled.
  @LDAPField(attribute="enabled",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private Boolean[] enabled;

  // The field used for optional attribute internalUrl.
  @LDAPField(attribute="internalUrl",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] internalUrl;

  // The field used for optional attribute openStackType.
  @LDAPField(attribute="openStackType",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] openStackType;

  // The field used for optional attribute policyId.
  @LDAPField(attribute="policyId",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] policyId;

  // The field used for optional attribute rsAdminUrl.
  @LDAPField(attribute="rsAdminUrl",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] rsAdminUrl;

  // The field used for optional attribute rsGlobal.
  @LDAPField(attribute="rsGlobal",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private Boolean[] rsGlobal;

  // The field used for optional attribute rsRegion.
  @LDAPField(attribute="rsRegion",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] rsRegion;

  // The field used for optional attribute service.
  @LDAPField(attribute="service",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] service;

  // The field used for optional attribute versionId.
  @LDAPField(attribute="versionId",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] versionId;

  // The field used for optional attribute versionInfo.
  @LDAPField(attribute="versionInfo",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] versionInfo;

  // The field used for optional attribute versionList.
  @LDAPField(attribute="versionList",
             objectClass="baseUrl",
             filterUsage=FilterUsage.CONDITIONALLY_ALLOWED)
  private String[] versionList;



  /**
   * Creates a new instance of this object.  All fields will be uninitialized,
   * so the setter methods should be used to assign values to them.
   */
  public BaseUrl()
  {
    // No initialization will be performed by default.  Note that if you set
    // values for any fields marked with an @LDAPField, @LDAPDNField, or
    // @LDAPEntryField annotation, they will be overwritten in the course of
    // decoding initializing this object from an LDAP entry.
  }



  /**
   * Creates a new BaseUrl object decoded
   * from the provided entry.
   *
   * @param  entry  The entry to be decoded.
   *
   * @return  The decoded BaseUrl object.
   *
   * @throws  LDAPPersistException  If a problem occurs while attempting to
   *                                decode the provided entry.
   */
  public static BaseUrl decode(final Entry entry)
         throws LDAPPersistException
  {
    return getPersister().decode(entry);
  }



  /**
   * Retrieves an {@code LDAPPersister} instance that may be used to interact
   * with objects of this type.
   *
   * @return  An {@code LDAPPersister} instance that may be used to interact
   *          with objects of this type.
   *
   * @throws  LDAPPersistException  If a problem occurs while creating the
   *                                {@code LDAPPersister} instance.
   */
  public static LDAPPersister<BaseUrl> getPersister()
         throws LDAPPersistException
  {
    return LDAPPersister.getInstance(BaseUrl.class);
  }



  /**
   * Performs any processing that may be necessary after initializing this
   * object from an LDAP entry.
   *
   * @throws  LDAPPersistException  If the generated entry should not be used.
   */
  private void doPostDecode()
          throws LDAPPersistException
  {
    // No processing is needed by default.  You may provide an implementation
    // for this method if custom post-decode processing is needed.
  }



  /**
   * Performs any processing that may be necessary after encoding this object
   * to an LDAP entry.
   *
   * @param  entry  The entry that has been generated.  It may be altered if
   *                desired.
   *
   * @throws  LDAPPersistException  If there is a problem with the object after
   *                                it has been decoded from an LDAP entry.
   */
  private void doPostEncode(final Entry entry)
          throws LDAPPersistException
  {
    // No processing is needed by default.  You may provide an implementation
    // for this method if custom post-encode processing is needed.
  }



  /**
   * Retrieves a read-only copy of the entry with which this object is
   * associated, if it is available.  It will only be available if this object
   * was decoded from or encoded to an LDAP entry.
   *
   * @return  A read-only copy of the entry with which this object is
   *          associated, or {@code null} if it is not available.
   */
  public ReadOnlyEntry getLDAPEntry()
  {
    return ldapEntry;
  }



  /**
   * Retrieves the DN of the entry with which this object is associated, if it
   * is available.  It will only be available if this object was decoded from or
   * encoded to an LDAP entry.
   *
   * @return  The DN of the entry with which this object is associated, or
   *          {@code null} if it is not available.
   */
  public String getLDAPEntryDN()
  {
    if (ldapEntry == null)
    {
      return null;
    }
    else
    {
      return ldapEntry.getDN();
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * rsId attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          rsId attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstRsId()
  {
    if ((rsId == null) ||
        (rsId.length == 0))
    {
      return null;
    }
    else
    {
      return rsId[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * rsId attribute, if present.
   *
   * @return  The values for the field associated with the
   *          rsId attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getRsId()
  {
    return rsId;
  }



  /**
   * Sets the values for the field associated with the
   * rsId attribute.
   *
   * @param  v  The values for the field associated with the
   *            rsId attribute.
   */
  public void setRsId(final String... v)
  {
    this.rsId = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the rsId attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateRsIdFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "rsId");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "rsid");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "rsId").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "rsId");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "rsId",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "rsId",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "rsId",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "rsId",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "rsId",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "rsId",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "rsId",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * publicUrl attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          publicUrl attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstPublicUrl()
  {
    if ((publicUrl == null) ||
        (publicUrl.length == 0))
    {
      return null;
    }
    else
    {
      return publicUrl[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * publicUrl attribute, if present.
   *
   * @return  The values for the field associated with the
   *          publicUrl attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getPublicUrl()
  {
    return publicUrl;
  }



  /**
   * Sets the values for the field associated with the
   * publicUrl attribute.
   *
   * @param  v  The values for the field associated with the
   *            publicUrl attribute.
   */
  public void setPublicUrl(final String... v)
  {
    this.publicUrl = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the publicUrl attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generatePublicUrlFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "publicUrl");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "publicurl");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "publicUrl").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "publicUrl");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "publicUrl",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "publicUrl",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "publicUrl",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "publicUrl",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "publicUrl",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "publicUrl",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "publicUrl",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * baseUrlType attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          baseUrlType attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstBaseUrlType()
  {
    if ((baseUrlType == null) ||
        (baseUrlType.length == 0))
    {
      return null;
    }
    else
    {
      return baseUrlType[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * baseUrlType attribute, if present.
   *
   * @return  The values for the field associated with the
   *          baseUrlType attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getBaseUrlType()
  {
    return baseUrlType;
  }



  /**
   * Sets the values for the field associated with the
   * baseUrlType attribute.
   *
   * @param  v  The values for the field associated with the
   *            baseUrlType attribute.
   */
  public void setBaseUrlType(final String... v)
  {
    this.baseUrlType = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the baseUrlType attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateBaseUrlTypeFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "baseUrlType");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "baseurltype");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "baseUrlType").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "baseUrlType");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "baseUrlType",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "baseUrlType",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "baseUrlType",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "baseUrlType",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "baseUrlType",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "baseUrlType",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "baseUrlType",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * cn attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          cn attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstCn()
  {
    if ((cn == null) ||
        (cn.length == 0))
    {
      return null;
    }
    else
    {
      return cn[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * cn attribute, if present.
   *
   * @return  The values for the field associated with the
   *          cn attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getCn()
  {
    return cn;
  }



  /**
   * Sets the values for the field associated with the
   * cn attribute.
   *
   * @param  v  The values for the field associated with the
   *            cn attribute.
   */
  public void setCn(final String... v)
  {
    this.cn = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the cn attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateCnFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "cn");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "cn");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "cn").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "cn");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "cn",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "cn",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "cn",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "cn",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "cn",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "cn",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "cn",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * def attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          def attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public Boolean getFirstDef()
  {
    if ((def == null) ||
        (def.length == 0))
    {
      return null;
    }
    else
    {
      return def[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * def attribute, if present.
   *
   * @return  The values for the field associated with the
   *          def attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public Boolean[] getDef()
  {
    return def;
  }



  /**
   * Sets the values for the field associated with the
   * def attribute.
   *
   * @param  v  The values for the field associated with the
   *            def attribute.
   */
  public void setDef(final Boolean... v)
  {
    this.def = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the def attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateDefFilter(
                            final PersistFilterType filterType,
                            final Boolean value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "def");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "def");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new Boolean[] { value },
           "def").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "def");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "def",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "def",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "def",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "def",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "def",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "def",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "def",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * enabled attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          enabled attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public Boolean getFirstEnabled()
  {
    if ((enabled == null) ||
        (enabled.length == 0))
    {
      return null;
    }
    else
    {
      return enabled[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * enabled attribute, if present.
   *
   * @return  The values for the field associated with the
   *          enabled attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public Boolean[] getEnabled()
  {
    return enabled;
  }



  /**
   * Sets the values for the field associated with the
   * enabled attribute.
   *
   * @param  v  The values for the field associated with the
   *            enabled attribute.
   */
  public void setEnabled(final Boolean... v)
  {
    this.enabled = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the enabled attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateEnabledFilter(
                            final PersistFilterType filterType,
                            final Boolean value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "enabled");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "enabled");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new Boolean[] { value },
           "enabled").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "enabled");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "enabled",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "enabled",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "enabled",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "enabled",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "enabled",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "enabled",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "enabled",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * internalUrl attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          internalUrl attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstInternalUrl()
  {
    if ((internalUrl == null) ||
        (internalUrl.length == 0))
    {
      return null;
    }
    else
    {
      return internalUrl[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * internalUrl attribute, if present.
   *
   * @return  The values for the field associated with the
   *          internalUrl attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getInternalUrl()
  {
    return internalUrl;
  }



  /**
   * Sets the values for the field associated with the
   * internalUrl attribute.
   *
   * @param  v  The values for the field associated with the
   *            internalUrl attribute.
   */
  public void setInternalUrl(final String... v)
  {
    this.internalUrl = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the internalUrl attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateInternalUrlFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "internalUrl");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "internalurl");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "internalUrl").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "internalUrl");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "internalUrl",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "internalUrl",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "internalUrl",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "internalUrl",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "internalUrl",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "internalUrl",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "internalUrl",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * openStackType attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          openStackType attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstOpenStackType()
  {
    if ((openStackType == null) ||
        (openStackType.length == 0))
    {
      return null;
    }
    else
    {
      return openStackType[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * openStackType attribute, if present.
   *
   * @return  The values for the field associated with the
   *          openStackType attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getOpenStackType()
  {
    return openStackType;
  }



  /**
   * Sets the values for the field associated with the
   * openStackType attribute.
   *
   * @param  v  The values for the field associated with the
   *            openStackType attribute.
   */
  public void setOpenStackType(final String... v)
  {
    this.openStackType = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the openStackType attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateOpenStackTypeFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "openStackType");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "openstacktype");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "openStackType").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "openStackType");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "openStackType",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "openStackType",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "openStackType",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "openStackType",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "openStackType",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "openStackType",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "openStackType",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * policyId attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          policyId attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstPolicyId()
  {
    if ((policyId == null) ||
        (policyId.length == 0))
    {
      return null;
    }
    else
    {
      return policyId[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * policyId attribute, if present.
   *
   * @return  The values for the field associated with the
   *          policyId attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getPolicyId()
  {
    return policyId;
  }



  /**
   * Sets the values for the field associated with the
   * policyId attribute.
   *
   * @param  v  The values for the field associated with the
   *            policyId attribute.
   */
  public void setPolicyId(final String... v)
  {
    this.policyId = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the policyId attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generatePolicyIdFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "policyId");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "policyid");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "policyId").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "policyId");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "policyId",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "policyId",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "policyId",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "policyId",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "policyId",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "policyId",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "policyId",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * rsAdminUrl attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          rsAdminUrl attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstRsAdminUrl()
  {
    if ((rsAdminUrl == null) ||
        (rsAdminUrl.length == 0))
    {
      return null;
    }
    else
    {
      return rsAdminUrl[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * rsAdminUrl attribute, if present.
   *
   * @return  The values for the field associated with the
   *          rsAdminUrl attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getRsAdminUrl()
  {
    return rsAdminUrl;
  }



  /**
   * Sets the values for the field associated with the
   * rsAdminUrl attribute.
   *
   * @param  v  The values for the field associated with the
   *            rsAdminUrl attribute.
   */
  public void setRsAdminUrl(final String... v)
  {
    this.rsAdminUrl = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the rsAdminUrl attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateRsAdminUrlFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "rsAdminUrl");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "rsadminurl");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "rsAdminUrl").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "rsAdminUrl");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "rsAdminUrl",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "rsAdminUrl",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "rsAdminUrl",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "rsAdminUrl",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "rsAdminUrl",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "rsAdminUrl",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "rsAdminUrl",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * rsGlobal attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          rsGlobal attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public Boolean getFirstRsGlobal()
  {
    if ((rsGlobal == null) ||
        (rsGlobal.length == 0))
    {
      return null;
    }
    else
    {
      return rsGlobal[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * rsGlobal attribute, if present.
   *
   * @return  The values for the field associated with the
   *          rsGlobal attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public Boolean[] getRsGlobal()
  {
    return rsGlobal;
  }



  /**
   * Sets the values for the field associated with the
   * rsGlobal attribute.
   *
   * @param  v  The values for the field associated with the
   *            rsGlobal attribute.
   */
  public void setRsGlobal(final Boolean... v)
  {
    this.rsGlobal = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the rsGlobal attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateRsGlobalFilter(
                            final PersistFilterType filterType,
                            final Boolean value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "rsGlobal");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "rsglobal");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new Boolean[] { value },
           "rsGlobal").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "rsGlobal");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "rsGlobal",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "rsGlobal",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "rsGlobal",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "rsGlobal",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "rsGlobal",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "rsGlobal",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "rsGlobal",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * rsRegion attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          rsRegion attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstRsRegion()
  {
    if ((rsRegion == null) ||
        (rsRegion.length == 0))
    {
      return null;
    }
    else
    {
      return rsRegion[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * rsRegion attribute, if present.
   *
   * @return  The values for the field associated with the
   *          rsRegion attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getRsRegion()
  {
    return rsRegion;
  }



  /**
   * Sets the values for the field associated with the
   * rsRegion attribute.
   *
   * @param  v  The values for the field associated with the
   *            rsRegion attribute.
   */
  public void setRsRegion(final String... v)
  {
    this.rsRegion = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the rsRegion attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateRsRegionFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "rsRegion");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "rsregion");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "rsRegion").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "rsRegion");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "rsRegion",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "rsRegion",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "rsRegion",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "rsRegion",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "rsRegion",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "rsRegion",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "rsRegion",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * service attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          service attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstService()
  {
    if ((service == null) ||
        (service.length == 0))
    {
      return null;
    }
    else
    {
      return service[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * service attribute, if present.
   *
   * @return  The values for the field associated with the
   *          service attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getService()
  {
    return service;
  }



  /**
   * Sets the values for the field associated with the
   * service attribute.
   *
   * @param  v  The values for the field associated with the
   *            service attribute.
   */
  public void setService(final String... v)
  {
    this.service = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the service attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateServiceFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "service");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "service");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "service").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "service");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "service",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "service",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "service",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "service",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "service",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "service",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "service",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * versionId attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          versionId attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstVersionId()
  {
    if ((versionId == null) ||
        (versionId.length == 0))
    {
      return null;
    }
    else
    {
      return versionId[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * versionId attribute, if present.
   *
   * @return  The values for the field associated with the
   *          versionId attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getVersionId()
  {
    return versionId;
  }



  /**
   * Sets the values for the field associated with the
   * versionId attribute.
   *
   * @param  v  The values for the field associated with the
   *            versionId attribute.
   */
  public void setVersionId(final String... v)
  {
    this.versionId = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the versionId attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateVersionIdFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "versionId");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "versionid");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "versionId").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "versionId");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "versionId",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "versionId",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "versionId",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "versionId",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "versionId",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "versionId",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "versionId",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * versionInfo attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          versionInfo attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstVersionInfo()
  {
    if ((versionInfo == null) ||
        (versionInfo.length == 0))
    {
      return null;
    }
    else
    {
      return versionInfo[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * versionInfo attribute, if present.
   *
   * @return  The values for the field associated with the
   *          versionInfo attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getVersionInfo()
  {
    return versionInfo;
  }



  /**
   * Sets the values for the field associated with the
   * versionInfo attribute.
   *
   * @param  v  The values for the field associated with the
   *            versionInfo attribute.
   */
  public void setVersionInfo(final String... v)
  {
    this.versionInfo = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the versionInfo attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateVersionInfoFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "versionInfo");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "versioninfo");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "versionInfo").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "versionInfo");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "versionInfo",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "versionInfo",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "versionInfo",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "versionInfo",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "versionInfo",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "versionInfo",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "versionInfo",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves the first value for the field associated with the
   * versionList attribute, if present.
   *
   * @return  The first value for the field associated with the
   *          versionList attribute, or
   *          {@code null} if that attribute was not present in the entry or
   *          does not have any values.
   */
  public String getFirstVersionList()
  {
    if ((versionList == null) ||
        (versionList.length == 0))
    {
      return null;
    }
    else
    {
      return versionList[0];
    }
  }



  /**
   * Retrieves the values for the field associated with the
   * versionList attribute, if present.
   *
   * @return  The values for the field associated with the
   *          versionList attribute, or
   *          {@code null} if that attribute was not present in the entry.
   */
  public String[] getVersionList()
  {
    return versionList;
  }



  /**
   * Sets the values for the field associated with the
   * versionList attribute.
   *
   * @param  v  The values for the field associated with the
   *            versionList attribute.
   */
  public void setVersionList(final String... v)
  {
    this.versionList = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the versionList attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateVersionListFilter(
                            final PersistFilterType filterType,
                            final String value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "versionList");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "versionlist");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           new String[] { value },
           "versionList").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "versionList");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "versionList",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "versionList",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "versionList",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "versionList",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "versionList",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "versionList",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "versionList",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }



  /**
   * Retrieves a string representation of this
   * {@code BaseUrl} object.
   *
   * @return  A string representation of this
   *          {@code BaseUrl} object.
   */
  @Override()
  public String toString()
  {
    final StringBuilder buffer = new StringBuilder();
    toString(buffer);
    return buffer.toString();
  }



  /**
   * Appends a string representation of this
   * {@code BaseUrl} object
   * to the provided buffer.
   *
   * @param  buffer  The buffer to which the string representation should be
   *                 appended.
   */
  public void toString(final StringBuilder buffer)
  {
    buffer.append("BaseUrl(");

    boolean appended = false;
    if (ldapEntry != null)
    {
      appended = true;
      buffer.append("entryDN='");
      buffer.append(ldapEntry.getDN());
      buffer.append('\'');
    }

    if (publicUrl != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("publicUrl=");
      buffer.append(Arrays.toString(publicUrl));
    }

    if (rsId != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("rsId=");
      buffer.append(Arrays.toString(rsId));
    }

    if (baseUrlType != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("baseUrlType=");
      buffer.append(Arrays.toString(baseUrlType));
    }

    if (cn != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("cn=");
      buffer.append(Arrays.toString(cn));
    }

    if (def != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("def=");
      buffer.append(Arrays.toString(def));
    }

    if (enabled != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("enabled=");
      buffer.append(Arrays.toString(enabled));
    }

    if (internalUrl != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("internalUrl=");
      buffer.append(Arrays.toString(internalUrl));
    }

    if (openStackType != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("openStackType=");
      buffer.append(Arrays.toString(openStackType));
    }

    if (policyId != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("policyId=");
      buffer.append(Arrays.toString(policyId));
    }

    if (rsAdminUrl != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("rsAdminUrl=");
      buffer.append(Arrays.toString(rsAdminUrl));
    }

    if (rsGlobal != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("rsGlobal=");
      buffer.append(Arrays.toString(rsGlobal));
    }

    if (rsRegion != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("rsRegion=");
      buffer.append(Arrays.toString(rsRegion));
    }

    if (service != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("service=");
      buffer.append(Arrays.toString(service));
    }

    if (versionId != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("versionId=");
      buffer.append(Arrays.toString(versionId));
    }

    if (versionInfo != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("versionInfo=");
      buffer.append(Arrays.toString(versionInfo));
    }

    if (versionList != null)
    {
      if (appended)
      {
        buffer.append(", ");
      }
      appended = true;
      buffer.append("versionList=");
      buffer.append(Arrays.toString(versionList));
    }

    buffer.append(')');
  }
}

